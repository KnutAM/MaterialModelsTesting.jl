var documenterSearchIndex = {"docs":
[{"location":"#MaterialModelsTesting","page":"Home","title":"MaterialModelsTesting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MaterialModelsTesting.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#MaterialModelsTesting.are_derivatives_equal-Tuple","page":"Home","title":"MaterialModelsTesting.are_derivatives_equal","text":"are_derivatives_equal(args...; maxtol = Inf, kwargs...)\n\nCalls compare_derivatives (forwarding args and kwargs) and checks if the  derivatives are equal. The maximum allowed absolute tolerance can also be checked by setting maxtol.\n\n\n\n\n\n","category":"method"},{"location":"#MaterialModelsTesting.compare_derivatives-Tuple{AbstractMatrix, AbstractMatrix, Vector, Vector}","page":"Home","title":"MaterialModelsTesting.compare_derivatives","text":"compare_derivatives(dydx::Matrix, dydx_num::Matrix, y::Vector, Δx::Vector; tolscale = 1)\n\nComparing derivatives with numerical values can be tricky, due to catastrophic cancellation easily  making the numerical derivatives inaccurate. This function uses the following formula to determine the appropriate tolerance for comparing the derivatives, which is based on the values of the  differentiated function, 'y', the pertubation for each entry, Δx. 'atol = 2 * eps(y) / Δx`.\n\nIt returns the error scaled by the tolerance for all entries, e, such that the derivatives can be considered equal if all(x -> x ≤ 1, e)\n\n\n\n\n\n","category":"method"},{"location":"#MaterialModelsTesting.obtain_numerical_material_derivative!-Tuple{MaterialModelsBase.MaterialDerivatives, MaterialModelsBase.AbstractMaterial, Any, Any, Any}","page":"Home","title":"MaterialModelsTesting.obtain_numerical_material_derivative!","text":"obtain_numerical_material_derivative!(deriv, m, ϵ, old, Δt; fdtype = Val{:forward}, kwargs...)\n\nObtain the numerical derivative of the material m at the strain ϵ and old state variables, old, for a time step Δt. fdtype and kwargs... are passed to FiniteDiff.finite_difference_jacobian. \n\n\n\n\n\n","category":"method"},{"location":"#MaterialModelsTesting.obtain_numerical_material_derivative!-Tuple{MaterialModelsBase.StressStateDerivatives, MaterialModelsBase.AbstractStressState, MaterialModelsBase.AbstractMaterial, Any, Any, Any}","page":"Home","title":"MaterialModelsTesting.obtain_numerical_material_derivative!","text":"obtain_numerical_material_derivative!(ssd, stress_state, m, ϵ, old, Δt; fdtype = Val{:forward}, kwargs...)\n\nObtain the numerical derivative of the material m considering the stress_state iterations at the strain  ϵ and old state variables, old, for a time step Δt. fdtype and kwargs... are passed to FiniteDiff.finite_difference_jacobian. \n\n\n\n\n\n","category":"method"},{"location":"#MaterialModelsTesting.runstrain-Tuple{Any, Union{Number, Tensors.AbstractTensor}, Any, Any, Any}","page":"Home","title":"MaterialModelsTesting.runstrain","text":"runstrain(m, ϵ_end::Union{Number, AbstractTensor}, ij::NTuple{2, Int}, t_end, num_steps)\n\nSimulate fully strain-controlled loading from zero to ϵ_end strain, and return σ[i,j].  If ϵ_end::Number is passed, loading is applied to the strain ϵ_end eᵢ⊗eⱼ. \n\nReturns the vector of stresses as well as the final state. \n\n\n\n\n\n","category":"method"},{"location":"#MaterialModelsTesting.runstrain_diff-Tuple{Any, Union{Number, Tensors.AbstractTensor}, Any, Any, Any}","page":"Home","title":"MaterialModelsTesting.runstrain_diff","text":"runstrain_diff(m, ϵ_end::Union{Number, AbstractTensor}, ij::NTuple{2, Int}, t_end, num_steps)\n\nSimulate fully strain-controlled loading from zero to ϵ_end strain, and return σ[i,j] and its derivatives wrt. to the material parameters. If ϵ_end::Number is passed, loading is applied to the strain ϵ_end eᵢ⊗eⱼ. \n\nReturns the vector of stresses, the final state, the derivatives dσᵢⱼ/dp for all time steps, and the final  derivatives diff::MaterialDerivatives. \n\n\n\n\n\n","category":"method"},{"location":"#MaterialModelsTesting.runstresstate-Tuple{Any, Any, Union{Number, Tensors.AbstractTensor}, Any, Any, Any}","page":"Home","title":"MaterialModelsTesting.runstresstate","text":"runstresstate(stress_state, m, ϵ_end::Union{Number, AbstractTensor}, ij::NTuple{2, Int}, t_end, num_steps)\n\nSimulate the stress_state from zero to ϵ_end strain, and return σ[i,j]. If ϵ_end::Number is passed, loading is applied to the strain ϵ_end eᵢ⊗eⱼ. \n\nReturns the vector of stresses and the final state variables.\n\n\n\n\n\n","category":"method"},{"location":"#MaterialModelsTesting.runstresstate_diff-Tuple{Any, Any, Union{Number, Tensors.AbstractTensor}, Any, Any, Any}","page":"Home","title":"MaterialModelsTesting.runstresstate_diff","text":"runstresstate_diff(stress_state, m, ϵ_end::Union{Number, AbstractTensor}, ij::NTuple{2, Int}, t_end, num_steps)\n\nSimulate the stress_state from zero to ϵ_end strain, and return σ[i,j] and its derivatives wrt. to the material parameters. If ϵ_end::Number is passed, loading is applied to the strain ϵ_end eᵢ⊗eⱼ. \n\nReturns the vector of stresses, the final state, the derivatives dσᵢⱼ/dp for all time steps, and the final  derivatives diff::StressStateDerivatives.\n\n\n\n\n\n","category":"method"},{"location":"#MaterialModelsTesting.test_derivative-NTuple{4, Any}","page":"Home","title":"MaterialModelsTesting.test_derivative","text":"test_derivative(m, ϵ, state, Δt; comparesettings = (), numdiffsettings = (), diff = MaterialDerivatives(m))\n\nThis function is used to compare the analytically implemented derivative (calling differentiate_material!(diff, m, ϵ, args...)) with the result from obtain_numerical_material_derivative!(diff, m, ϵ, args...; numdiffsettings...).\n\ndiff::MaterialDerivatives can be passed to check that the old value of diff.dsdp is correctly accounted for.\ncomparesettings::NamedTuple are passed as kwargs to compare_derivatives, which compares the two matrices. Please see its docstring for further details.\nnumdiffsettings::NamedTuple are passed as kwargs to obtain_numerical_material_derivative!, please see its docstring for further details. \n\n\n\n\n\n","category":"method"},{"location":"#MaterialModelsTesting.test_material","page":"Home","title":"MaterialModelsTesting.test_material","text":"test_material(m::AbstractMaterial, [loadinfo::LoadInfo];\n    basics = true, conversions = false, differentiation = false\n    )\n\nFunction to quickly test that the material m follows the MaterialModelsBase interface, and that what generally should hold true, does. All material models should pass the basics tests, which are on by default, whereas the conversions and differentiation tests are optional.\n\nloadinfo gives information about how much the material is loaded, and different values can be supplied if required for the specific material model/parameters. \n\nbasics (default: true)\n\nTests that required functions - initial_material_state and allocate_material_cache returns the correct types, and runs the material_response to check that the outputs are of correct type. Furthermore, it checks that the tangent stiffness matches with the numerical derivative, although this test is only approximate.\n\nconversions (default: false)\n\nTests the conversions tovector, tovector!, fromvector for both the material parameters and the state variables, along with the associated methods get_num_params, get_num_statevars, get_params_eltype, and get_statevar_eltype. Furthermore, it is tested that initial_material_state returns a state using the element type from the material, and that the conversions respect the different element types of the given vector. Since also Float32 is used in this testing, it is important not to  default to using Float64 when creating e.g. state variables, i.e. use zero(Tensor{2,3,T}) instead  of zeros(Tensor{2,3}).\n\ndifferentiation (default: false)\n\nTests that the differentiate_material! function works correctly. Uses BigFloat to calculate the  numerical derivatives to avoid floating point errors.\n\n\n\n\n\n","category":"function"}]
}
